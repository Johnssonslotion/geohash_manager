from glob import glob
import os
import pandas as pd
import geopandas as gpd
import pygeohash as pgh
from shapely.geometry import Polygon
from tqdm import tqdm
import warnings

## from polygon to geohash rect sets


class geohash_manage:
    def __init__(self, precision=6):
        self.precision = precision

    def geohash_rect(self, geohash):
        """
        single geohash to rect polygon
        :return geohashset, polygon
        """
        ## from geohash to single rect polygon
        lat, lon, lat_err, lon_err = pgh.decode_exactly(geohash)

        wn = (lon - lon_err, lat + lat_err)
        en = (lon + lon_err, lat + lat_err)
        es = (lon + lon_err, lat - lat_err)
        ws = (lon - lon_err, lat - lat_err)
        polygon = Polygon([wn, en, es, ws])
        return [ws, es, en, wn], polygon

    def subhash(self, geohash):
        ## geohash 아래의 하위 geohash를 반환합니다.
        ## geohash length : 4 km error : 39.1km(+/-19.5km))
        ## geohash length : 5 km error : 4.9km(+/-2.4km))
        base32_chars = "0123456789bcdefghjkmnpqrstuvwxyz"
        current_precision = len(geohash)
        if current_precision == self.precision:
            return []
        else:
            ret = []
            for i in base32_chars:
                ret.append(geohash + str(i))
            return ret

    def geohash_neighbors(self, geohash, precision, direction=None):
        """Geohash 문자열의 이웃하는 문자열을 반환합니다.

        Args:
            geohash (str): 이웃하는 문자열을 찾을 Geohash 문자열.
            direction (str): 이웃하는 문자열의 방향을 지정합니다.
                가능한 값은 'top', 'bottom', 'left', 'right', 'topleft', 'topright', 'bottomleft', 'bottomright', 'all' 입니다.
                기본값은 'all' 입니다.

        Returns:
            list[str]: 이웃하는 Geohash 문자열의 리스트.
        """
        if direction is None:
            direction = "all"

        # 이웃하는 문자열의 방향에 대한 정보를 설정합니다.
        direction_info = {
            "top": {"n": 1, "e": 0},
            "bottom": {"n": -1, "e": 0},
            "left": {"n": 0, "e": -1},
            "right": {"n": 0, "e": 1},
            "topleft": {"n": 1, "e": -1},
            "topright": {"n": 1, "e": 1},
            "bottomleft": {"n": -1, "e": -1},
            "bottomright": {"n": -1, "e": 1},
            "all": {"n": 0, "e": 0},
        }
        # Geohash 문자열의 위치 정보를 계산합니다.
        lat, lon, lat_err, lon_err = pgh.decode_exactly(geohash)
        lat_err *= 2
        lon_err *= 2

        # 이웃하는 문자열의 위치 정보를 계산합니다.
        n_delta = direction_info[direction]["n"]
        e_delta = direction_info[direction]["e"]
        neighbor_lat = lat + n_delta * lat_err
        neighbor_lon = lon + e_delta * lon_err

        # 이웃하는 문자열의 Geohash 문자열을 생성합니다.
        neighbor_geohash = pgh.encode(neighbor_lat, neighbor_lon, precision=precision)

        # 결과를 반환합니다.
        return neighbor_geohash

    def cover_geohash(self, target_polygon, precision):
        """
        to find geohash rect covered by polygon.
        target_polygon: polygon
        geohash: single geohash
        precision: geohash precision
        :return geohash set covered by polygon
        """

        geohash_set = set()

        ## from polygon to geohash rect sets
        target_edge = target_polygon.bounds  ## xmin,ymin,xmax,ymax
        init_edge_geohash = pgh.encode(target_edge[1], target_edge[0], precision)
        top_edge_geohash = pgh.encode(target_edge[3], target_edge[0], precision)
        right_edge_geohash = pgh.encode(target_edge[1], target_edge[2], precision)
        end_edge_geohash = pgh.encode(target_edge[3], target_edge[2], precision)
        ## geohash(xmin,ymin) to geohash(xmax,ymax) search geohash
        ## generate geohash neighbors

        ### all geohash rect generated by geohash neighbors, will be add to candidate_all
        ### and all generated geohash will be check if it is covered by polygon
        ### if it is covered, it will be add to geoash_set

        candidate_all = list()

        ### top candidate
        def loop_check_right_step(geohash, end_geohash, precision):
            candidate = list()
            right_step = geohash
            while True:
                right_step = self.geohash_neighbors(
                    right_step, precision, direction="right"
                )
                target_polygon = self.geohash_rect(end_geohash)[1]
                right_step_polygon = self.geohash_rect(right_step)[1]
                if right_step_polygon.intersects(target_polygon):
                    candidate.append(right_step)
                    right_step = self.geohash_neighbors(
                        right_step, precision, direction="right"
                    )
                    candidate.append(right_step)
                    break
                else:
                    candidate.append(right_step)
            return candidate

        def loop_check_up_step(init_candidate, top_candidate, precision):
            iter = 0
            for i in range(len(top_candidate)):
                iter += 1
                end_polygon = self.geohash_rect(top_candidate[i])[1]
                up_step = init_candidate[i]
                up_step_polygon = self.geohash_rect(init_candidate[i])[1]
                candidate_all.append(init_candidate[i])
                while up_step_polygon.intersects(end_polygon) != True:
                    up_step = self.geohash_neighbors(
                        up_step, precision, direction="top"
                    )
                    up_step_polygon = self.geohash_rect(up_step)[1]
                    candidate_all.append(up_step)
            return candidate_all

        init_candidate = loop_check_right_step(
            init_edge_geohash, right_edge_geohash, precision
        )
        top_candidate = loop_check_right_step(
            top_edge_geohash, end_edge_geohash, precision
        )
        candidate_all = loop_check_up_step(init_candidate, top_candidate, precision)

        for i in candidate_all:
            _, check = self.geohash_rect(i)
            if check.intersects(target_polygon):
                geohash_set.add(i)
            else:
                pass
        return geohash_set

    def geohash_set_to_polygon(self, geohash_set):
        """ """
        polygon_list = []
        for i in geohash_set:
            _, polygon = self.geohash_rect(i)
            polygon_list.append(polygon)
        return polygon_list

    def extract_rect_from_shp(self, shp_file, precision):
        """
        shp_file: shp file path
        precision: geohash precision
        :return geohash set covered by polygon
        """
        before_file = shp_file
        shp = gpd.read_file(shp_file, encoding="cp949").to_crs("EPSG:4326")
        after_file = before_file.replace(".shp", f"_geohash_prec_{precision}.geojson")
        print("break point")
        warnings.filterwarnings("ignore", category=DeprecationWarning)

        gdf = gpd.GeoDataFrame()
        list_gdf_single = list()
        for i in tqdm(range(len(shp))):
            i = shp.iloc[i]
            geohash_set = self.cover_geohash(i.geometry, precision=precision)
            ### 여기까지 정상
            polygon_list = self.geohash_set_to_polygon(geohash_set)
            ## append using concat
            gdf_single = gpd.GeoDataFrame()
            for ii, jj in enumerate(polygon_list):
                single_item = i.copy()
                single_item["geometry"] = jj
                single_item["geohash"] = pgh.encode(
                    jj.centroid.y, jj.centroid.x, precision=precision
                )  ### 바뀌었음.
                single_item["cluster"] = ii
                list_gdf_single.append(single_item)
            gdf_single = pd.DataFrame.from_records(list_gdf_single)
            gdf = pd.concat([gdf, gdf_single], ignore_index=True)
        geometry = gdf["geometry"]
        gdf = gdf.drop(columns=["geometry"])
        gdf = gpd.GeoDataFrame(gdf, geometry=geometry)
        gdf.to_file(after_file, driver="GeoJSON", encoding="utf-8")
        return gdf

    def extract_rect_from_series(self, series_geohash):
        """
        shp_file: shp file path
        :return geohash set covered by polygon
        """

        ## series pd.Series geohash

        gdf = gpd.GeoDataFrame()

        for i in tqdm(range(len(series_geohash))):
            i = series_geohash.iloc[i]
            polygon_list = self.geohash_set_to_polygon(i["geohash"])
            ## append using concat
            single_item = i.copy()
            list_gdf_single = list()
            for jj in polygon_list:
                single_item["geometry"] = jj
                single_item["geohash"] = i["geohash"]
                list_gdf_single = gdf_single.append(single_item, ignore_index=True)
            gdf_single = pd.DataFrame.from_records(list_gdf_single)
            gdf = pd.concat([gdf, gdf_single], ignore_index=True)

        geometry = gdf["geometry"]
        gdf = gdf.drop(columns=["geometry"])
        gdf = gpd.GeoDataFrame(gdf, geometry=geometry)
        return gdf


if __name__ == "__main__":
    ## from polygon to geohash rect added gpd dataframe to export geojson file

    path = os.path.dirname(os.path.abspath(__file__))
    sgg_folder = os.path.join(path, "../data/sgg")
    glob_list = glob(os.path.join(sgg_folder, "*.shp"))
    glob_list = [
        "/Volumes/WorkSpace/work/ds/geoinfo/geoinfo/src/../data/sgg/LARD_ADM_SECT_SGG_48.shp"
    ]
    for i in glob_list:
        if i == os.path.join(sgg_folder, "*41.shp"):
            pass
        print(i)
        geohash_base = geohash_manage()
        # geohash_base.extract_rect_from_shp(i,precision=5)
        geohash_base.extract_rect_from_shp(i, precision=6)
        # geohash_base.extract_rect_from_shp(i,precision=7)
        # geohash_base.extract_rect_from_shp(i,precision=8)
